<html>
<head>
    <title>r/Place 2022 Timeline by u/scaevolus</title>
</head>
<body style="overflow:hidden;margin:0;background-color:black;color:white;">
<div style="margin:5px;display:flex;">
    <span id="timestamp"></span>&nbsp;<span id="speed" style="width:3em;text-align:center;">5x</span>
    <input id="slider" type="range" min="0" list="steplist" max="400" value="330" style="flex-grow:1;display:inline;" draggable="false">
    <datalist id="steplist">
        <option>0</option>
        <option>100</option>
        <option>200</option>
        <option>300</option>
        <option>400</option>
    </datalist>
</div>
<div id="viewport" style="height:100%;user-select:none;overflow:clip">
    <canvas id="canvas" style="image-rendering:pixelated;touch-action:none"  width="2000" height="2000" ondragstart="return false">
    </div>
</body>
<script type="text/javascript">
"use strict";

const palette = [
"#6D001A", "#BE0039", "#FF4500", "#FFA800", "#FFD635", "#FFF8B8", "#00A368", "#00CC78",
"#7EED56", "#00756F", "#009EAA", "#00CCC0", "#2450A4", "#3690EA", "#51E9F4", "#493AC1",
"#6A5CFF", "#94B3FF", "#811E9F", "#B44AC0", "#E4ABFF", "#DE107F", "#FF3881", "#FF99AA",
"#6D482F", "#9C6926", "#FFB470", "#000000", "#515252", "#898D90", "#D4D7D9", "#FFFFFF",
];

const pal = [];

for (let c of palette) {
    pal.push(parseInt(c.slice(1, 3), 16));
    pal.push(parseInt(c.slice(3, 5), 16));
    pal.push(parseInt(c.slice(5, 7), 16));
}

let speed = 1;
let speedticks = 0;

function calcSpeed() {
    let val = slider.value/10;
    speedticks = 0;
    if (18 < val && val < 22) {
        return 0;
    } else if (val > 20) {
        return Math.pow(2, val-20);
    } else {
        return -Math.pow(2, 20-val);
    }
}

slider.oninput = function() {
    let newSpeed = calcSpeed();
    if (Math.sign(newSpeed) != Math.sign(speed)) {
        curGroup += newSpeed > 0 ? 1 : -1;
    }
    speed = newSpeed;
    let s = 60*speed/1000;
    document.getElementById("speed").innerText = ("" + (s>1||s<-1?s|0:Math.round(s*100)/100)) + "x";
}
slider.oninput();

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function sleepFrame() {
    return new Promise(requestAnimationFrame);
}

let quadseen = 0;
let quadstart = [0, 0, 0, 0];

let pixelsPaletted = new Uint8Array(2000*2000);
for (let i = 0; i < pixelsPaletted.length; i++) {
    pixelsPaletted[i] = 31; // white
}

function updateTimestamp() {
    timestamp.innerText = new Date(startTime + curTs).toISOString().slice(0, 19);
}

async function renderLoop() {
    let ctx = canvas.getContext('2d');

    let imageData = ctx.getImageData(0, 0, 2000, 2000);;
    let pixels = imageData.data;

    function dumpImageData(all) {
        if (all) {
            ctx.putImageData(imageData, 0, 0);
        } else {
            ctx.putImageData(imageData, 0, 0, 0, 0, 1000 + 500 * (quadseen & 2), 1000 + 250 * (quadseen & 4));
        }
    }

    let lastSleep = 0;

    function set(x, y, col) {
        let o = 4 * (x + y * 2000);
        pixels[o+0] = pal[3 * col];
        pixels[o+1] = pal[3 * col + 1];
        pixels[o+2] = pal[3 * col + 2];
        pixels[o+3] = 255;
    }

    function xor(x, y, col_xor) {
        let col = pixelsPaletted[x + y * 2000] ^= col_xor;
        let o = 4 * (x + y * 2000);
        pixels[o+0] = pal[3 * col];
        pixels[o+1] = pal[3 * col + 1];
        pixels[o+2] = pal[3 * col + 2];
    }

    function desaturate() {
        let f = 0.04; // desaturate by 10%

        for (let i = 0; i < pixels.length; i += 4) {
            let r = pixels[i], g = pixels[i+1], b = pixels[i + 2];
            // https://stackoverflow.com/a/20820649/3694
            let L = r * 0.3 + g * 0.6 + b * .1;

            pixels[i] = r + f * (L - r);
            pixels[i+1] = g + f * (L - g);
            pixels[i+2] = b + f * (L - b);
        }
    }


    while (true) {
        let next = nextEvent();
        while (!next) {
            await loadNextBuf();
            next = nextEvent();
            if (!next) {
                await sleep(100);
            }
        }
        let {count, oct, buf, evtStart} = next;

        let i = evtStart;

        if (count === 0) {
            console.log("end?");
            return;
        }

        let ox = 1000 * (oct & 1);
        let oy = 250 * (oct & 6);

        let quad = (oct&1)+((oct&4)>>1);

        if (curGroup === 1 && speed > 0) {
            // clear canvas
            for (let o = 0; o < pixels.length; o += 4) {
                pixels[o] = 0;
                pixels[o+1] = 0;
                pixels[o+2] = 0;
            }
            updateTimestamp();
            dumpImageData();
            quadseen = 0;
        }

        if (!(quadseen & (1<<quad))) {
            quadstart[quad] ||= curGroup;
            quadseen |= 1 << quad;

            let sx = 1000 * (quad & 1), sy = 1000 * (quad >> 1);

            console.log("fwd-white-quad", quad, curGroup, sx, sy, quadstart[quad]);
            for (let y = sy; y < sy + 1000; y++) {
                for (let x = sx; x < sx + 1000; x++) {
                    set(x, y, 31);
                }
            }
        }

        for (let cq = 1; speed < 0 && cq < 4; cq++) {
            if (quadstart[cq] != curGroup + 2) {
                continue;
            }

            let sx = 1000 * (cq & 1), sy = 1000 * (cq >> 1);

            console.log("rev-black-quad", cq, curGroup, sx, sy);

            for (let y = sy; y < sy + 1000; y++) {
                for (let x = sx; x < sx + 1000; x++) {
                    set(x, y, 27);
                }
            }
            dumpImageData(true);
            quadseen ^= 1 << cq;
        }


        for (let j = 0; j < count; j++) {
            let x = buf[i] + ((buf[i+1]<<8)&0x300);
            let y = (buf[i+1]>>2)+((buf[i+2]<<6)&0x1FF);
            let col = buf[i+2]>>3;
            xor(ox + x, oy + y, col);
            i += 3;
        }

        if (Math.abs(curTs - lastSleep) > Math.abs(speed)) {
            updateTimestamp();
            dumpImageData();
            // desaturate();
            await sleepFrame();
            while (speed == 0) {
                await sleepFrame();
            }
            if (Math.abs(speed) < 100 && speedticks > 30) {
                let slack = Math.min(1500, Math.abs((curTs - lastSleep) / (60*speed/1000)));
                await sleep(slack);
            }
            speedticks++;
            lastSleep = curTs;
        }
    }
    updateTimestamp();
    dumpImageData();
}

const N_BUFS = 84;
let bufs = [];

// group lengths can exceed a 16-bit integer,
// so it's best to just pack the offsets as 24b with a 7b buf id
let groupOffsets = new Uint32Array(5542545);
let curGroup = 0;
let curBuf = 0;
let curIndex = 0;
let curTs = 0;
let startTime = 0;

async function loadNextBuf(dir) {
    function startFetch(n) {
        bufs[n] = fetch('data/eventsxor.' + (""+n).padStart(3, "0") + ".bin");
    }

    if (bufs[curBuf] === null) {
        startFetch(curBuf);
    }
    if (bufs[curBuf] instanceof Promise) {
        bufs[curBuf] = await bufs[curBuf];
    }
    if (bufs[curBuf] instanceof Response) {
        if (!bufs[curBuf].ok) {
            console.log("bad");
            bufs[curBuf] = false;
            return;
        }
        bufs[curBuf] = new Uint8Array(await (await bufs[curBuf].blob()).arrayBuffer())
    }
    if (!bufs[curBuf] instanceof Uint8Array) {
        console.log("weird buffer?", curBuf);
        return;
    }

    if (curBuf + 1 < N_BUFS && bufs[curBuf + 1] === null) {
        startFetch(curBuf + 1);
    }
    if (curBuf + 2 < N_BUFS && bufs[curBuf + 2] === null) {
        startFetch(curBuf + 2);
    }
}

function nextEvent() {
    if (curBuf === -1 && speed > 0) {
        curBuf = 0;
        curIndex = 16;
        curGroup = 0;
        curTs = 0;
    }

    let buf = bufs[curBuf];

    if (!(buf instanceof Uint8Array)) {
        return;
    }

    if (!buf.lastTs) {
        buf.lastTs = true;

        let magic = new TextDecoder().decode(buf.slice(0,8));
        if (magic !== "PIXLPACK") {
            console.log('bad magic', magic);
            return;
        }

        startTime = buf[8]|(buf[9]<<8)|(buf[10]<<16);
        let startTimeHi = buf[11]|(buf[12]<<8)|(buf[13]<<16);
        startTime = (startTime) + (startTimeHi*16777216);

        curIndex = 16;
    }

    function readUvarint() {
        let x = 0;
        let s = 0;
        while (1) {
            let c = buf[curIndex++];
            x |= (c & 127) << s;
            if (!(c & 128)) {
                break;
            }
            s += 7;
        }
        return x;
    }

    if (curIndex < buf.byteLength && curIndex >= 16 && curGroup >= 0) {
        let start = curIndex;
        let to = readUvarint();
        let ocount = readUvarint();
        let count = ocount >> 3;
        let oct = ocount & 7;

        let evtStart = curIndex, evtEnd = curIndex + count * 3;

        if (speed > 0) {
            curTs += to;
            groupOffsets[curGroup] = (start << 7) | curBuf;
            curIndex += count * 3;
            curGroup++;
        } else {
            curTs -= to;
            curGroup--;
            curIndex = groupOffsets[curGroup] >>> 7;
            let newBuf = groupOffsets[curGroup] & 0x7f;
            if (newBuf !== curBuf) {
                curBuf = newBuf;
                curTs = bufs[curBuf].lastTs;
            }
        }

        if (evtEnd > buf.length) {
            throw "group too long?";
        }

        return {count, oct, buf, evtStart};
    }

    if (speed > 0) {
        buf.lastTs = curTs;
        curBuf = (curBuf + 1) % N_BUFS;
        if (curBuf <= 0) {
            curGroup = 0;
        }
        curIndex = 16;
        curTs = 0;
    } else {
        curBuf = curBuf - 1;
        if (curBuf < 0) {
            if (bufs[N_BUFS - 1]) {
                curBuf = N_BUFS - 1;
                curGroup = groupOffsets.length - 1;
                curIndex = groupOffsets[curGroup] >>> 7;
                curBuf = groupOffsets[curGroup] & 0x7f;
                curTs = bufs[curBuf].lastTs;
                quadseen = 0;
            } else {
                return;
            }
        }
        curTs = bufs[curBuf].lastTs;
    }
}


for (var i = 0; i < N_BUFS; i++) {
    bufs.push(null);
}

renderLoop();

// PAN/ZOOM

var zoom = 1;
var tx = 0, ty = 0;

viewport.onwheel = function(e) {
    let bounds = viewport.getBoundingClientRect();
    let cx = e.clientX - bounds.left;
    let cy = e.clientY - bounds.top;
    let mx = 1000-(1000-(cx-tx))/zoom;
    let my = 1000-(1000-(cy-ty))/zoom;

    let oldZoom = zoom;

    zoom = Math.min(14, Math.max(0, (zoom > 8 ? 2 : 1) * Math.sign(-e.deltaY) + zoom|0));
    if (zoom === 0) {
        zoom = 0.5;
    }

    if (zoom === oldZoom) {
        return;
    }

    // thanks, wolframalpha! solving for mx_beforezoom=mx_afterzoom,
    // to keep the point the mouse is hovering over invariant after the zoom.
    tx = zoom * (1000 + tx - cx) / oldZoom + cx - 1000;
    ty = zoom * (1000 + ty - cy) / oldZoom + cy - 1000;

    canvas.style["image-rendering"] = zoom < 1 ? 'auto' : 'pixelated';
    updateTransform();
}

function updateTransform() {
    // clamp translation to canvas bounds
    tx = Math.min(tx, viewport.clientWidth - 20 - ((-1000 * zoom) + 1000));
    tx = Math.max(tx, 20 - ((500 * (quadseen & 2) * zoom) + 1000));
    ty = Math.min(ty, viewport.clientHeight - 60 - ((-1000 * zoom) + 1000));
    ty = Math.max(ty, 20 - ((250 * (quadseen & 4) * zoom) + 1000));

    canvas.style.transform = "translate(" + tx + "px," + ty + "px) scale(" + zoom + ")";
}

window.onresize = updateTransform;

viewport.onmousemove = function(e) {
    if (e.buttons) {
        tx += e.movementX;
        ty += e.movementY;
        updateTransform();
    }
}
updateTransform();
</script>
</html>
