<html>
<head>
    <title>r/Place 2022 Timeline by u/scaevolus</title>
</head>
<body style="overflow:hidden;margin:0;background-color:black;color:white;">
<div style="margin:5px;display:flex;">
    <span id="timestamp"></span>&nbsp;<span id="speed" style="width:3em;text-align:center;">5x</span>
    <input id="slider" type="range" min="200" list="steplist" max="400" value="330" style="flex-grow:1;display:inline;">
    <datalist id="steplist">
        <option>0</option>
        <option>100</option>
        <option>200</option>
        <option>300</option>
        <option>400</option>
    </datalist>
</div>
<div id="viewport" style="height:100%;user-select:none;overflow:clip">
    <canvas id="canvas" style="image-rendering:pixelated;touch-action:none"  width="2000" height="2000" ondragstart="return false">
    </div>
</body>
<script type="text/javascript">
"use strict";

const palette = [
"#6D001A", "#BE0039", "#FF4500", "#FFA800", "#FFD635", "#FFF8B8", "#00A368", "#00CC78",
"#7EED56", "#00756F", "#009EAA", "#00CCC0", "#2450A4", "#3690EA", "#51E9F4", "#493AC1",
"#6A5CFF", "#94B3FF", "#811E9F", "#B44AC0", "#E4ABFF", "#DE107F", "#FF3881", "#FF99AA",
"#6D482F", "#9C6926", "#FFB470", "#000000", "#515252", "#898D90", "#D4D7D9", "#FFFFFF",
];

const pal = [];

for (let c of palette) {
    pal.push(parseInt(c.slice(1, 3), 16));
    pal.push(parseInt(c.slice(3, 5), 16));
    pal.push(parseInt(c.slice(5, 7), 16));
}

function calcSpeed() {
    let val = slider.value/10;
    if (17 < val && val < 23) {
        return 0;
    } else if (val > 20) {
        return Math.pow(2, val-20);
    } else {
        return -Math.pow(2, 20-val);
    }
}

slider.oninput = function() {
    let s = 60*calcSpeed()/1000;
    speed.innerText = ("" + (s>1||s<-1?s|0:Math.round(s*100)/100)) + "x";
}
slider.oninput();

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function sleepFrame() {
    return new Promise(requestAnimationFrame);
}

let quadseen = 0;

let pixelsPaletted = new Uint8Array(2000*2000);
for (let i = 0; i < pixelsPaletted.length; i++) {
    pixelsPaletted[i] = 31; // white
}

async function renderBuf(buf) {
    let magic = new TextDecoder().decode(buf.slice(0,8));
    if (magic !== "PIXLPACK") {
        console.log('bad magic', magic);
        return;
    }

    buf = buf.slice(8);

    let startTime = buf[0]|(buf[1]<<8)|(buf[2]<<16);
    let startTimeHi = buf[3]|(buf[4]<<8)|(buf[5]<<16);
    startTime = (startTime) + (startTimeHi*16777216);

    let i = 8;
    let t = 0;

    function readUvarint() {
        let x = 0;
        let s = 0;
        while (1) {
            let c = buf[i++];
            x |= (c & 127) << s;
            if (!(c & 128)) {
                break;
            }
            s += 7;
        }
        return x;
    }

    let ctx = canvas.getContext('2d');

    let imageData = ctx.getImageData(0, 0, 2000, 2000);;
    let pixels = imageData.data;

    function dumpImageData() {
        ctx.putImageData(imageData, 0, 0);
    }

    let lastSleep = 0;

    function set(x, y, col) {
        let o = 4 * (x + y * 2000);
        pixels[o+0] = pal[3 * col];
        pixels[o+1] = pal[3 * col + 1];
        pixels[o+2] = pal[3 * col + 2];
        pixels[o+3] = 255;
    }

    function xor(x, y, col_xor) {
        let col = pixelsPaletted[x + y * 2000] ^= col_xor;
        let o = 4 * (x + y * 2000);
        pixels[o+0] = pal[3 * col];
        pixels[o+1] = pal[3 * col + 1];
        pixels[o+2] = pal[3 * col + 2];
    }

    function updateTimestamp() {
        timestamp.innerText = new Date(startTime + t).toISOString().slice(0, 19);
    }

    while (i < buf.byteLength) {
        let to = readUvarint();
        let ocount = readUvarint();
        let count = ocount >> 3;
        let oct = ocount & 7;
        let ox = 1000 * (oct & 1);
        let oy = 250 * (oct & 6);

        let quad = (oct&1)+((oct&4)>>1);

        if (!(quadseen & (1<<quad))) {
            quadseen |= 1 << quad;

            let sx = 1000 * (quad & 1), sy = 1000 * (quad >> 1);
            for (let y = sy; y < sy + 1000; y++) {
                for (let x = sx; x < sx + 1000; x++) {
                    set(x, y, 31);
                }
            }
        }

        for (let j = 0; j < count; j++) {
            let x = buf[i] + ((buf[i+1]<<8)&0x300);
            let y = (buf[i+1]>>2)+((buf[i+2]<<6)&0x1FF);
            let col = buf[i+2]>>3;
            xor(ox + x, oy + y, col);
            i += 3;
        }

        t += to;

        if (t - lastSleep > calcSpeed()) {
            updateTimestamp();
            dumpImageData();
            await sleepFrame();
            lastSleep = t;
        }
    }
    updateTimestamp();
    dumpImageData();
}

async function grabData() {
    let res, nextRes;
    for (var n = 0; n <= 84; n++) {
        res = nextRes;
        nextRes = n < 84 ? await fetch('data/eventsxor.' + (""+n).padStart(3, "0") + ".bin") : null;
        if (!res) continue;
        if (!res.ok) { console.log("bad"); return }
        let buf = new Uint8Array(await (await res.blob()).arrayBuffer());
        await renderBuf(buf);
    }
}
grabData();

var zoom = 1;
var tx = 0, ty = 0;

viewport.onwheel = function(e) {
    let mx = 1000-(1000-(e.clientX-tx))/zoom;
    let my = 1000-(1000-(e.clientY-ty))/zoom;

    let oldZoom = zoom;

    zoom = Math.min(10, Math.max(0, Math.sign(e.deltaY) + zoom|0));
    if (zoom === 0) {
        zoom = 0.5;
    }

    if (zoom === oldZoom) {
        return;
    }

    // thanks, wolframalpha! solving for mx_beforezoom=mx_afterzoom,
    // to keep the point the mouse is hovering over invariant after the zoom.
    tx = zoom * (1000 + tx - e.clientX) / oldZoom + e.clientX - 1000;
    ty = zoom * (1000 + ty - e.clientY) / oldZoom + e.clientY - 1000;

    canvas.style["image-rendering"] = zoom < 1 ? 'auto' : 'pixelated';
    updateTransform();
}

function updateTransform() {
    // clamp translation to canvas bounds
    tx = Math.min(tx, viewport.clientWidth - 20 - ((-1000 * zoom) + 1000));
    tx = Math.max(tx, 20 - ((500 * (quadseen & 2) * zoom) + 1000));
    ty = Math.min(ty, viewport.clientHeight - 60 - ((-1000 * zoom) + 1000));
    ty = Math.max(ty, 20 - ((250 * (quadseen & 4) * zoom) + 1000));

    canvas.style.transform = "translate(" + tx + "px," + ty + "px) scale(" + zoom + ")";
}

window.onresize = updateTransform;

viewport.onmousemove = function(e) {
    if (e.buttons) {
        tx += e.movementX;
        ty += e.movementY;
        updateTransform();
    }
}
updateTransform();
</script>
</html>
